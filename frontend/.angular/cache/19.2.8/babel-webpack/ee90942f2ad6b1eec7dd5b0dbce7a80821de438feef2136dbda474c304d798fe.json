{"ast":null,"code":"import { SourceType } from 'storybook/internal/docs-tools';\nimport { useRef, emitTransformCode, useEffect } from 'storybook/preview-api';\nimport { computesTemplateSourceFromComponent } from '../../renderer';\nexport const skipSourceRender = context => {\n  const sourceParams = context?.parameters.docs?.source;\n  // always render if the user forces it\n  if (sourceParams?.type === SourceType.DYNAMIC) {\n    return false;\n  }\n  // never render if the user is forcing the block to render code, or\n  // if the user provides code\n  return sourceParams?.code || sourceParams?.type === SourceType.CODE;\n};\n/**\n * Angular source decorator.\n *\n * @param storyFn Fn\n * @param context StoryContext\n */\nexport const sourceDecorator = (storyFn, context) => {\n  const story = storyFn();\n  const source = useRef(undefined);\n  useEffect(() => {\n    if (skipSourceRender(context)) {\n      return;\n    }\n    const {\n      props,\n      userDefinedTemplate\n    } = story;\n    const {\n      component,\n      argTypes,\n      parameters\n    } = context;\n    const template = parameters.docs?.source?.excludeDecorators ? context.originalStoryFn(context.args, context).template : story.template;\n    if (component && !userDefinedTemplate) {\n      const sourceFromComponent = computesTemplateSourceFromComponent(component, props, argTypes);\n      // We might have a story with a Directive or Service defined as the component\n      // In these cases there might exist a template, even if we aren't able to create source from component\n      const newSource = sourceFromComponent || template;\n      if (newSource && newSource !== source.current) {\n        emitTransformCode(newSource, context);\n        source.current = newSource;\n      }\n    } else if (template && template !== source.current) {\n      emitTransformCode(template, context);\n      source.current = template;\n    }\n  });\n  return story;\n};","map":{"version":3,"names":["SourceType","useRef","emitTransformCode","useEffect","computesTemplateSourceFromComponent","skipSourceRender","context","sourceParams","parameters","docs","source","type","DYNAMIC","code","CODE","sourceDecorator","storyFn","story","undefined","props","userDefinedTemplate","component","argTypes","template","excludeDecorators","originalStoryFn","args","sourceFromComponent","newSource","current"],"sources":["C:/Users/Arianna/Code/RirisCozyNook/frontend/node_modules/@storybook/angular/dist/client/docs/sourceDecorator.mjs"],"sourcesContent":["import { SourceType } from 'storybook/internal/docs-tools';\nimport { useRef, emitTransformCode, useEffect } from 'storybook/preview-api';\nimport { computesTemplateSourceFromComponent } from '../../renderer';\nexport const skipSourceRender = (context) => {\n    const sourceParams = context?.parameters.docs?.source;\n    // always render if the user forces it\n    if (sourceParams?.type === SourceType.DYNAMIC) {\n        return false;\n    }\n    // never render if the user is forcing the block to render code, or\n    // if the user provides code\n    return sourceParams?.code || sourceParams?.type === SourceType.CODE;\n};\n/**\n * Angular source decorator.\n *\n * @param storyFn Fn\n * @param context StoryContext\n */\nexport const sourceDecorator = (storyFn, context) => {\n    const story = storyFn();\n    const source = useRef(undefined);\n    useEffect(() => {\n        if (skipSourceRender(context)) {\n            return;\n        }\n        const { props, userDefinedTemplate } = story;\n        const { component, argTypes, parameters } = context;\n        const template = parameters.docs?.source?.excludeDecorators\n            ? context.originalStoryFn(context.args, context).template\n            : story.template;\n        if (component && !userDefinedTemplate) {\n            const sourceFromComponent = computesTemplateSourceFromComponent(component, props, argTypes);\n            // We might have a story with a Directive or Service defined as the component\n            // In these cases there might exist a template, even if we aren't able to create source from component\n            const newSource = sourceFromComponent || template;\n            if (newSource && newSource !== source.current) {\n                emitTransformCode(newSource, context);\n                source.current = newSource;\n            }\n        }\n        else if (template && template !== source.current) {\n            emitTransformCode(template, context);\n            source.current = template;\n        }\n    });\n    return story;\n};\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,+BAA+B;AAC1D,SAASC,MAAM,EAAEC,iBAAiB,EAAEC,SAAS,QAAQ,uBAAuB;AAC5E,SAASC,mCAAmC,QAAQ,gBAAgB;AACpE,OAAO,MAAMC,gBAAgB,GAAIC,OAAO,IAAK;EACzC,MAAMC,YAAY,GAAGD,OAAO,EAAEE,UAAU,CAACC,IAAI,EAAEC,MAAM;EACrD;EACA,IAAIH,YAAY,EAAEI,IAAI,KAAKX,UAAU,CAACY,OAAO,EAAE;IAC3C,OAAO,KAAK;EAChB;EACA;EACA;EACA,OAAOL,YAAY,EAAEM,IAAI,IAAIN,YAAY,EAAEI,IAAI,KAAKX,UAAU,CAACc,IAAI;AACvE,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAGA,CAACC,OAAO,EAAEV,OAAO,KAAK;EACjD,MAAMW,KAAK,GAAGD,OAAO,CAAC,CAAC;EACvB,MAAMN,MAAM,GAAGT,MAAM,CAACiB,SAAS,CAAC;EAChCf,SAAS,CAAC,MAAM;IACZ,IAAIE,gBAAgB,CAACC,OAAO,CAAC,EAAE;MAC3B;IACJ;IACA,MAAM;MAAEa,KAAK;MAAEC;IAAoB,CAAC,GAAGH,KAAK;IAC5C,MAAM;MAAEI,SAAS;MAAEC,QAAQ;MAAEd;IAAW,CAAC,GAAGF,OAAO;IACnD,MAAMiB,QAAQ,GAAGf,UAAU,CAACC,IAAI,EAAEC,MAAM,EAAEc,iBAAiB,GACrDlB,OAAO,CAACmB,eAAe,CAACnB,OAAO,CAACoB,IAAI,EAAEpB,OAAO,CAAC,CAACiB,QAAQ,GACvDN,KAAK,CAACM,QAAQ;IACpB,IAAIF,SAAS,IAAI,CAACD,mBAAmB,EAAE;MACnC,MAAMO,mBAAmB,GAAGvB,mCAAmC,CAACiB,SAAS,EAAEF,KAAK,EAAEG,QAAQ,CAAC;MAC3F;MACA;MACA,MAAMM,SAAS,GAAGD,mBAAmB,IAAIJ,QAAQ;MACjD,IAAIK,SAAS,IAAIA,SAAS,KAAKlB,MAAM,CAACmB,OAAO,EAAE;QAC3C3B,iBAAiB,CAAC0B,SAAS,EAAEtB,OAAO,CAAC;QACrCI,MAAM,CAACmB,OAAO,GAAGD,SAAS;MAC9B;IACJ,CAAC,MACI,IAAIL,QAAQ,IAAIA,QAAQ,KAAKb,MAAM,CAACmB,OAAO,EAAE;MAC9C3B,iBAAiB,CAACqB,QAAQ,EAAEjB,OAAO,CAAC;MACpCI,MAAM,CAACmB,OAAO,GAAGN,QAAQ;IAC7B;EACJ,CAAC,CAAC;EACF,OAAON,KAAK;AAChB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}