{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Arianna/Code/RirisCozyNook/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nconst queue = [];\nlet isProcessing = false;\n/**\n * Reset compiled components because we often want to compile the same component with more than one\n * NgModule.\n */\nconst resetCompiledComponents = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* () {\n    try {\n      // Clear global Angular component cache in order to be able to re-render the same component across multiple stories\n      //\n      // References:\n      // https://github.com/angular/angular-cli/blob/master/packages/angular_devkit/build_angular/src/webpack/plugins/hmr/hmr-accept.ts#L50\n      // https://github.com/angular/angular/blob/2ebe2bcb2fe19bf672316b05f15241fd7fd40803/packages/core/src/render3/jit/module.ts#L377-L384\n      const {\n        ɵresetCompiledComponents\n      } = yield import('@angular/core');\n      ɵresetCompiledComponents();\n    } catch (e) {\n      /** Noop catch This means angular removed or modified ɵresetCompiledComponents */\n    }\n  });\n  return function resetCompiledComponents() {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Queue bootstrapping, so that only one application can be bootstrapped at a time.\n *\n * Bootstrapping multiple applications at once can cause Angular to throw an error that a component\n * is declared in multiple modules. This avoids two stories confusing the Angular compiler, by\n * bootstrapping more that one application at a time.\n *\n * @param fn Callback that should complete the bootstrap process\n * @returns ApplicationRef from the completed bootstrap process\n */\nexport const queueBootstrapping = fn => {\n  return new Promise((resolve, reject) => {\n    queue.push(() => fn().then(resolve).catch(reject));\n    if (!isProcessing) {\n      processQueue();\n    }\n  });\n};\nconst processQueue = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* () {\n    isProcessing = true;\n    while (queue.length > 0) {\n      const bootstrappingFn = queue.shift();\n      if (bootstrappingFn) {\n        yield bootstrappingFn();\n        yield resetCompiledComponents();\n      }\n    }\n    isProcessing = false;\n  });\n  return function processQueue() {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["queue","isProcessing","resetCompiledComponents","_ref","_asyncToGenerator","ɵresetCompiledComponents","e","apply","arguments","queueBootstrapping","fn","Promise","resolve","reject","push","then","catch","processQueue","_ref2","length","bootstrappingFn","shift"],"sources":["C:/Users/Arianna/Code/RirisCozyNook/frontend/node_modules/@storybook/angular/dist/client/angular-beta/utils/BootstrapQueue.mjs"],"sourcesContent":["const queue = [];\nlet isProcessing = false;\n/**\n * Reset compiled components because we often want to compile the same component with more than one\n * NgModule.\n */\nconst resetCompiledComponents = async () => {\n    try {\n        // Clear global Angular component cache in order to be able to re-render the same component across multiple stories\n        //\n        // References:\n        // https://github.com/angular/angular-cli/blob/master/packages/angular_devkit/build_angular/src/webpack/plugins/hmr/hmr-accept.ts#L50\n        // https://github.com/angular/angular/blob/2ebe2bcb2fe19bf672316b05f15241fd7fd40803/packages/core/src/render3/jit/module.ts#L377-L384\n        const { ɵresetCompiledComponents } = await import('@angular/core');\n        ɵresetCompiledComponents();\n    }\n    catch (e) {\n        /** Noop catch This means angular removed or modified ɵresetCompiledComponents */\n    }\n};\n/**\n * Queue bootstrapping, so that only one application can be bootstrapped at a time.\n *\n * Bootstrapping multiple applications at once can cause Angular to throw an error that a component\n * is declared in multiple modules. This avoids two stories confusing the Angular compiler, by\n * bootstrapping more that one application at a time.\n *\n * @param fn Callback that should complete the bootstrap process\n * @returns ApplicationRef from the completed bootstrap process\n */\nexport const queueBootstrapping = (fn) => {\n    return new Promise((resolve, reject) => {\n        queue.push(() => fn().then(resolve).catch(reject));\n        if (!isProcessing) {\n            processQueue();\n        }\n    });\n};\nconst processQueue = async () => {\n    isProcessing = true;\n    while (queue.length > 0) {\n        const bootstrappingFn = queue.shift();\n        if (bootstrappingFn) {\n            await bootstrappingFn();\n            await resetCompiledComponents();\n        }\n    }\n    isProcessing = false;\n};\n"],"mappings":";AAAA,MAAMA,KAAK,GAAG,EAAE;AAChB,IAAIC,YAAY,GAAG,KAAK;AACxB;AACA;AACA;AACA;AACA,MAAMC,uBAAuB;EAAA,IAAAC,IAAA,GAAAC,iBAAA,CAAG,aAAY;IACxC,IAAI;MACA;MACA;MACA;MACA;MACA;MACA,MAAM;QAAEC;MAAyB,CAAC,SAAS,MAAM,CAAC,eAAe,CAAC;MAClEA,wBAAwB,CAAC,CAAC;IAC9B,CAAC,CACD,OAAOC,CAAC,EAAE;MACN;IAAA;EAER,CAAC;EAAA,gBAbKJ,uBAAuBA,CAAA;IAAA,OAAAC,IAAA,CAAAI,KAAA,OAAAC,SAAA;EAAA;AAAA,GAa5B;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,kBAAkB,GAAIC,EAAE,IAAK;EACtC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACpCb,KAAK,CAACc,IAAI,CAAC,MAAMJ,EAAE,CAAC,CAAC,CAACK,IAAI,CAACH,OAAO,CAAC,CAACI,KAAK,CAACH,MAAM,CAAC,CAAC;IAClD,IAAI,CAACZ,YAAY,EAAE;MACfgB,YAAY,CAAC,CAAC;IAClB;EACJ,CAAC,CAAC;AACN,CAAC;AACD,MAAMA,YAAY;EAAA,IAAAC,KAAA,GAAAd,iBAAA,CAAG,aAAY;IAC7BH,YAAY,GAAG,IAAI;IACnB,OAAOD,KAAK,CAACmB,MAAM,GAAG,CAAC,EAAE;MACrB,MAAMC,eAAe,GAAGpB,KAAK,CAACqB,KAAK,CAAC,CAAC;MACrC,IAAID,eAAe,EAAE;QACjB,MAAMA,eAAe,CAAC,CAAC;QACvB,MAAMlB,uBAAuB,CAAC,CAAC;MACnC;IACJ;IACAD,YAAY,GAAG,KAAK;EACxB,CAAC;EAAA,gBAVKgB,YAAYA,CAAA;IAAA,OAAAC,KAAA,CAAAX,KAAA,OAAAC,SAAA;EAAA;AAAA,GAUjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}