{"ast":null,"code":"import { Component, Directive, Input, Output, Pipe, ɵReflectionCapabilities as ReflectionCapabilities } from '@angular/core';\nconst reflectionCapabilities = new ReflectionCapabilities();\n/** Returns component Inputs / Outputs by browsing these properties and decorator */\nexport const getComponentInputsOutputs = component => {\n  const componentMetadata = getComponentDecoratorMetadata(component);\n  const componentPropsMetadata = getComponentPropsDecoratorMetadata(component);\n  const initialValue = {\n    inputs: [],\n    outputs: []\n  };\n  // Adds the I/O present in @Component metadata\n  if (componentMetadata && componentMetadata.inputs) {\n    initialValue.inputs.push(...componentMetadata.inputs.map(i => ({\n      propName: typeof i === 'string' ? i : i.name,\n      templateName: typeof i === 'string' ? i : i.alias\n    })));\n  }\n  if (componentMetadata && componentMetadata.outputs) {\n    initialValue.outputs.push(...componentMetadata.outputs.map(i => ({\n      propName: i,\n      templateName: i\n    })));\n  }\n  if (!componentPropsMetadata) {\n    return initialValue;\n  }\n  // Browses component properties to extract I/O\n  // Filters properties that have the same name as the one present in the @Component property\n  return Object.entries(componentPropsMetadata).reduce((previousValue, [propertyName, values]) => {\n    const value = values.find(v => v instanceof Input || v instanceof Output);\n    if (value instanceof Input) {\n      const inputToAdd = {\n        propName: propertyName,\n        templateName: value.bindingPropertyName ?? value.alias ?? propertyName\n      };\n      const previousInputsFiltered = previousValue.inputs.filter(i => i.templateName !== propertyName);\n      return {\n        ...previousValue,\n        inputs: [...previousInputsFiltered, inputToAdd]\n      };\n    }\n    if (value instanceof Output) {\n      const outputToAdd = {\n        propName: propertyName,\n        templateName: value.bindingPropertyName ?? value.alias ?? propertyName\n      };\n      const previousOutputsFiltered = previousValue.outputs.filter(i => i.templateName !== propertyName);\n      return {\n        ...previousValue,\n        outputs: [...previousOutputsFiltered, outputToAdd]\n      };\n    }\n    return previousValue;\n  }, initialValue);\n};\nexport const isDeclarable = component => {\n  if (!component) {\n    return false;\n  }\n  const decorators = reflectionCapabilities.annotations(component);\n  return !!(decorators || []).find(d => d instanceof Directive || d instanceof Pipe || d instanceof Component);\n};\nexport const isComponent = component => {\n  if (!component) {\n    return false;\n  }\n  const decorators = reflectionCapabilities.annotations(component);\n  return (decorators || []).some(d => d instanceof Component);\n};\nexport const isStandaloneComponent = component => {\n  if (!component) {\n    return false;\n  }\n  const decorators = reflectionCapabilities.annotations(component);\n  // TODO: `standalone` is only available in Angular v14. Remove cast to `any` once\n  // Angular deps are updated to v14.x.x.\n  return (decorators || []).some(d => (d instanceof Component || d instanceof Directive || d instanceof Pipe) && d.standalone);\n};\n/** Returns all component decorator properties is used to get all `@Input` and `@Output` Decorator */\nexport const getComponentPropsDecoratorMetadata = component => {\n  return reflectionCapabilities.propMetadata(component);\n};\n/** Returns component decorator `@Component` */\nexport const getComponentDecoratorMetadata = component => {\n  const decorators = reflectionCapabilities.annotations(component);\n  return decorators.reverse().find(d => d instanceof Component);\n};","map":{"version":3,"names":["Component","Directive","Input","Output","Pipe","ɵReflectionCapabilities","ReflectionCapabilities","reflectionCapabilities","getComponentInputsOutputs","component","componentMetadata","getComponentDecoratorMetadata","componentPropsMetadata","getComponentPropsDecoratorMetadata","initialValue","inputs","outputs","push","map","i","propName","name","templateName","alias","Object","entries","reduce","previousValue","propertyName","values","value","find","v","inputToAdd","bindingPropertyName","previousInputsFiltered","filter","outputToAdd","previousOutputsFiltered","isDeclarable","decorators","annotations","d","isComponent","some","isStandaloneComponent","standalone","propMetadata","reverse"],"sources":["C:/Users/Arianna/Code/RirisCozyNook/frontend/node_modules/@storybook/angular/dist/client/angular-beta/utils/NgComponentAnalyzer.mjs"],"sourcesContent":["import { Component, Directive, Input, Output, Pipe, ɵReflectionCapabilities as ReflectionCapabilities, } from '@angular/core';\nconst reflectionCapabilities = new ReflectionCapabilities();\n/** Returns component Inputs / Outputs by browsing these properties and decorator */\nexport const getComponentInputsOutputs = (component) => {\n    const componentMetadata = getComponentDecoratorMetadata(component);\n    const componentPropsMetadata = getComponentPropsDecoratorMetadata(component);\n    const initialValue = {\n        inputs: [],\n        outputs: [],\n    };\n    // Adds the I/O present in @Component metadata\n    if (componentMetadata && componentMetadata.inputs) {\n        initialValue.inputs.push(...componentMetadata.inputs.map((i) => ({\n            propName: typeof i === 'string' ? i : i.name,\n            templateName: typeof i === 'string' ? i : i.alias,\n        })));\n    }\n    if (componentMetadata && componentMetadata.outputs) {\n        initialValue.outputs.push(...componentMetadata.outputs.map((i) => ({ propName: i, templateName: i })));\n    }\n    if (!componentPropsMetadata) {\n        return initialValue;\n    }\n    // Browses component properties to extract I/O\n    // Filters properties that have the same name as the one present in the @Component property\n    return Object.entries(componentPropsMetadata).reduce((previousValue, [propertyName, values]) => {\n        const value = values.find((v) => v instanceof Input || v instanceof Output);\n        if (value instanceof Input) {\n            const inputToAdd = {\n                propName: propertyName,\n                templateName: value.bindingPropertyName ?? value.alias ?? propertyName,\n            };\n            const previousInputsFiltered = previousValue.inputs.filter((i) => i.templateName !== propertyName);\n            return {\n                ...previousValue,\n                inputs: [...previousInputsFiltered, inputToAdd],\n            };\n        }\n        if (value instanceof Output) {\n            const outputToAdd = {\n                propName: propertyName,\n                templateName: value.bindingPropertyName ?? value.alias ?? propertyName,\n            };\n            const previousOutputsFiltered = previousValue.outputs.filter((i) => i.templateName !== propertyName);\n            return {\n                ...previousValue,\n                outputs: [...previousOutputsFiltered, outputToAdd],\n            };\n        }\n        return previousValue;\n    }, initialValue);\n};\nexport const isDeclarable = (component) => {\n    if (!component) {\n        return false;\n    }\n    const decorators = reflectionCapabilities.annotations(component);\n    return !!(decorators || []).find((d) => d instanceof Directive || d instanceof Pipe || d instanceof Component);\n};\nexport const isComponent = (component) => {\n    if (!component) {\n        return false;\n    }\n    const decorators = reflectionCapabilities.annotations(component);\n    return (decorators || []).some((d) => d instanceof Component);\n};\nexport const isStandaloneComponent = (component) => {\n    if (!component) {\n        return false;\n    }\n    const decorators = reflectionCapabilities.annotations(component);\n    // TODO: `standalone` is only available in Angular v14. Remove cast to `any` once\n    // Angular deps are updated to v14.x.x.\n    return (decorators || []).some((d) => (d instanceof Component || d instanceof Directive || d instanceof Pipe) && d.standalone);\n};\n/** Returns all component decorator properties is used to get all `@Input` and `@Output` Decorator */\nexport const getComponentPropsDecoratorMetadata = (component) => {\n    return reflectionCapabilities.propMetadata(component);\n};\n/** Returns component decorator `@Component` */\nexport const getComponentDecoratorMetadata = (component) => {\n    const decorators = reflectionCapabilities.annotations(component);\n    return decorators.reverse().find((d) => d instanceof Component);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}