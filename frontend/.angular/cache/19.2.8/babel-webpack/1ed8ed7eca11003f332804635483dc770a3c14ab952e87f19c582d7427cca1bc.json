{"ast":null,"code":"import { logger } from 'storybook/internal/client-logger';\nimport { global } from '@storybook/global';\nconst {\n  FEATURES\n} = global;\nexport const isMethod = methodOrProp => {\n  return methodOrProp.args !== undefined;\n};\nexport const setCompodocJson = compodocJson => {\n  global.__STORYBOOK_COMPODOC_JSON__ = compodocJson;\n};\nexport const getCompodocJson = () => global.__STORYBOOK_COMPODOC_JSON__;\nexport const checkValidComponentOrDirective = component => {\n  if (!component.name) {\n    throw new Error(`Invalid component ${JSON.stringify(component)}`);\n  }\n};\nexport const checkValidCompodocJson = compodocJson => {\n  if (!compodocJson || !compodocJson.components) {\n    throw new Error('Invalid compodoc JSON');\n  }\n};\nconst hasDecorator = (item, decoratorName) => item.decorators && item.decorators.find(x => x.name === decoratorName);\nconst mapPropertyToSection = item => {\n  if (hasDecorator(item, 'ViewChild')) {\n    return 'view child';\n  }\n  if (hasDecorator(item, 'ViewChildren')) {\n    return 'view children';\n  }\n  if (hasDecorator(item, 'ContentChild')) {\n    return 'content child';\n  }\n  if (hasDecorator(item, 'ContentChildren')) {\n    return 'content children';\n  }\n  return 'properties';\n};\nconst mapItemToSection = (key, item) => {\n  switch (key) {\n    case 'methods':\n    case 'methodsClass':\n      return 'methods';\n    case 'inputsClass':\n      return 'inputs';\n    case 'outputsClass':\n      return 'outputs';\n    case 'properties':\n    case 'propertiesClass':\n      if (isMethod(item)) {\n        throw new Error(\"Cannot be of type Method if key === 'propertiesClass'\");\n      }\n      return mapPropertyToSection(item);\n    default:\n      throw new Error(`Unknown key: ${key}`);\n  }\n};\nexport const findComponentByName = (name, compodocJson) => compodocJson.components.find(c => c.name === name) || compodocJson.directives.find(c => c.name === name) || compodocJson.pipes.find(c => c.name === name) || compodocJson.injectables.find(c => c.name === name) || compodocJson.classes.find(c => c.name === name);\nconst getComponentData = component => {\n  if (!component) {\n    return null;\n  }\n  checkValidComponentOrDirective(component);\n  const compodocJson = getCompodocJson();\n  if (!compodocJson) {\n    return null;\n  }\n  checkValidCompodocJson(compodocJson);\n  const {\n    name\n  } = component;\n  const metadata = findComponentByName(name, compodocJson);\n  if (!metadata) {\n    logger.warn(`Component not found in compodoc JSON: '${name}'`);\n  }\n  return metadata;\n};\nconst displaySignature = item => {\n  const args = item.args.map(arg => `${arg.name}${arg.optional ? '?' : ''}: ${arg.type}`);\n  return `(${args.join(', ')}) => ${item.returnType}`;\n};\nconst extractTypeFromValue = defaultValue => {\n  const valueType = typeof defaultValue;\n  return defaultValue || valueType === 'number' || valueType === 'boolean' || valueType === 'string' ? valueType : null;\n};\nconst extractEnumValues = compodocType => {\n  const compodocJson = getCompodocJson();\n  const enumType = compodocJson?.miscellaneous?.enumerations?.find(x => x.name === compodocType);\n  if (enumType?.childs.every(x => x.value)) {\n    return enumType.childs.map(x => x.value);\n  }\n  if (typeof compodocType !== 'string' || compodocType.indexOf('|') === -1) {\n    return null;\n  }\n  try {\n    return compodocType.split('|').map(value => JSON.parse(value));\n  } catch (e) {\n    return null;\n  }\n};\nexport const extractType = (property, defaultValue) => {\n  const compodocType = property.type || extractTypeFromValue(defaultValue);\n  switch (compodocType) {\n    case 'string':\n    case 'boolean':\n    case 'number':\n      return {\n        name: compodocType\n      };\n    case undefined:\n    case null:\n      return {\n        name: 'other',\n        value: 'void'\n      };\n    default:\n      {\n        const resolvedType = resolveTypealias(compodocType);\n        const enumValues = extractEnumValues(resolvedType);\n        return enumValues ? {\n          name: 'enum',\n          value: enumValues\n        } : {\n          name: 'other',\n          value: 'empty-enum'\n        };\n      }\n  }\n};\nconst castDefaultValue = (property, defaultValue) => {\n  const compodocType = property.type;\n  // All these checks are necessary as compodoc does not always set the type ie. @HostBinding have empty types.\n  // null and undefined also have 'any' type\n  if (['boolean', 'number', 'string', 'EventEmitter'].includes(compodocType)) {\n    switch (compodocType) {\n      case 'boolean':\n        return defaultValue === 'true';\n      case 'number':\n        return Number(defaultValue);\n      case 'EventEmitter':\n        return undefined;\n      default:\n        return defaultValue;\n    }\n  } else {\n    switch (defaultValue) {\n      case 'true':\n        return true;\n      case 'false':\n        return false;\n      case 'null':\n        return null;\n      case 'undefined':\n        return undefined;\n      default:\n        return defaultValue;\n    }\n  }\n};\nconst extractDefaultValueFromComments = (property, value) => {\n  let commentValue = value;\n  property.jsdoctags.forEach(tag => {\n    if (['default', 'defaultvalue'].includes(tag.tagName.escapedText)) {\n      const dom = new global.DOMParser().parseFromString(tag.comment, 'text/html');\n      commentValue = dom.body.textContent;\n    }\n  });\n  return commentValue;\n};\nconst extractDefaultValue = property => {\n  try {\n    let value = property.defaultValue?.replace(/^'(.*)'$/, '$1');\n    value = castDefaultValue(property, value);\n    if (value == null && property.jsdoctags?.length > 0) {\n      value = extractDefaultValueFromComments(property, value);\n    }\n    return value;\n  } catch (err) {\n    logger.debug(`Error extracting ${property.name}: ${property.defaultValue}`);\n    return undefined;\n  }\n};\nconst resolveTypealias = compodocType => {\n  const compodocJson = getCompodocJson();\n  const typeAlias = compodocJson?.miscellaneous?.typealiases?.find(x => x.name === compodocType);\n  return typeAlias ? resolveTypealias(typeAlias.rawtype) : compodocType;\n};\nexport const extractArgTypesFromData = componentData => {\n  const sectionToItems = {};\n  const componentClasses = FEATURES.angularFilterNonInputControls ? ['inputsClass'] : ['propertiesClass', 'methodsClass', 'inputsClass', 'outputsClass'];\n  const compodocClasses = ['component', 'directive'].includes(componentData.type) ? componentClasses : ['properties', 'methods'];\n  compodocClasses.forEach(key => {\n    const data = componentData[key] || [];\n    data.forEach(item => {\n      const section = mapItemToSection(key, item);\n      const defaultValue = isMethod(item) ? undefined : extractDefaultValue(item);\n      const type = isMethod(item) || section !== 'inputs' && section !== 'properties' ? {\n        name: 'other',\n        value: 'void'\n      } : extractType(item, defaultValue);\n      const action = section === 'outputs' ? {\n        action: item.name\n      } : {};\n      const argType = {\n        name: item.name,\n        description: item.rawdescription || item.description,\n        type,\n        ...action,\n        table: {\n          category: section,\n          type: {\n            summary: isMethod(item) ? displaySignature(item) : item.type,\n            required: isMethod(item) ? false : !item.optional\n          },\n          defaultValue: {\n            summary: defaultValue\n          }\n        }\n      };\n      if (!sectionToItems[section]) {\n        sectionToItems[section] = [];\n      }\n      sectionToItems[section].push(argType);\n    });\n  });\n  const SECTIONS = ['properties', 'inputs', 'outputs', 'methods', 'view child', 'view children', 'content child', 'content children'];\n  const argTypes = {};\n  SECTIONS.forEach(section => {\n    const items = sectionToItems[section];\n    if (items) {\n      items.forEach(argType => {\n        argTypes[argType.name] = argType;\n      });\n    }\n  });\n  return argTypes;\n};\nexport const extractArgTypes = component => {\n  const componentData = getComponentData(component);\n  return componentData && extractArgTypesFromData(componentData);\n};\nexport const extractComponentDescription = component => {\n  const componentData = getComponentData(component);\n  return componentData && (componentData.rawdescription || componentData.description);\n};","map":{"version":3,"names":["logger","global","FEATURES","isMethod","methodOrProp","args","undefined","setCompodocJson","compodocJson","__STORYBOOK_COMPODOC_JSON__","getCompodocJson","checkValidComponentOrDirective","component","name","Error","JSON","stringify","checkValidCompodocJson","components","hasDecorator","item","decoratorName","decorators","find","x","mapPropertyToSection","mapItemToSection","key","findComponentByName","c","directives","pipes","injectables","classes","getComponentData","metadata","warn","displaySignature","map","arg","optional","type","join","returnType","extractTypeFromValue","defaultValue","valueType","extractEnumValues","compodocType","enumType","miscellaneous","enumerations","childs","every","value","indexOf","split","parse","e","extractType","property","resolvedType","resolveTypealias","enumValues","castDefaultValue","includes","Number","extractDefaultValueFromComments","commentValue","jsdoctags","forEach","tag","tagName","escapedText","dom","DOMParser","parseFromString","comment","body","textContent","extractDefaultValue","replace","length","err","debug","typeAlias","typealiases","rawtype","extractArgTypesFromData","componentData","sectionToItems","componentClasses","angularFilterNonInputControls","compodocClasses","data","section","action","argType","description","rawdescription","table","category","summary","required","push","SECTIONS","argTypes","items","extractArgTypes","extractComponentDescription"],"sources":["C:/Users/Arianna/Code/RirisCozyNook/frontend/node_modules/@storybook/angular/dist/client/compodoc.mjs"],"sourcesContent":["import { logger } from 'storybook/internal/client-logger';\nimport { global } from '@storybook/global';\nconst { FEATURES } = global;\nexport const isMethod = (methodOrProp) => {\n    return methodOrProp.args !== undefined;\n};\nexport const setCompodocJson = (compodocJson) => {\n    global.__STORYBOOK_COMPODOC_JSON__ = compodocJson;\n};\nexport const getCompodocJson = () => global.__STORYBOOK_COMPODOC_JSON__;\nexport const checkValidComponentOrDirective = (component) => {\n    if (!component.name) {\n        throw new Error(`Invalid component ${JSON.stringify(component)}`);\n    }\n};\nexport const checkValidCompodocJson = (compodocJson) => {\n    if (!compodocJson || !compodocJson.components) {\n        throw new Error('Invalid compodoc JSON');\n    }\n};\nconst hasDecorator = (item, decoratorName) => item.decorators && item.decorators.find((x) => x.name === decoratorName);\nconst mapPropertyToSection = (item) => {\n    if (hasDecorator(item, 'ViewChild')) {\n        return 'view child';\n    }\n    if (hasDecorator(item, 'ViewChildren')) {\n        return 'view children';\n    }\n    if (hasDecorator(item, 'ContentChild')) {\n        return 'content child';\n    }\n    if (hasDecorator(item, 'ContentChildren')) {\n        return 'content children';\n    }\n    return 'properties';\n};\nconst mapItemToSection = (key, item) => {\n    switch (key) {\n        case 'methods':\n        case 'methodsClass':\n            return 'methods';\n        case 'inputsClass':\n            return 'inputs';\n        case 'outputsClass':\n            return 'outputs';\n        case 'properties':\n        case 'propertiesClass':\n            if (isMethod(item)) {\n                throw new Error(\"Cannot be of type Method if key === 'propertiesClass'\");\n            }\n            return mapPropertyToSection(item);\n        default:\n            throw new Error(`Unknown key: ${key}`);\n    }\n};\nexport const findComponentByName = (name, compodocJson) => compodocJson.components.find((c) => c.name === name) ||\n    compodocJson.directives.find((c) => c.name === name) ||\n    compodocJson.pipes.find((c) => c.name === name) ||\n    compodocJson.injectables.find((c) => c.name === name) ||\n    compodocJson.classes.find((c) => c.name === name);\nconst getComponentData = (component) => {\n    if (!component) {\n        return null;\n    }\n    checkValidComponentOrDirective(component);\n    const compodocJson = getCompodocJson();\n    if (!compodocJson) {\n        return null;\n    }\n    checkValidCompodocJson(compodocJson);\n    const { name } = component;\n    const metadata = findComponentByName(name, compodocJson);\n    if (!metadata) {\n        logger.warn(`Component not found in compodoc JSON: '${name}'`);\n    }\n    return metadata;\n};\nconst displaySignature = (item) => {\n    const args = item.args.map((arg) => `${arg.name}${arg.optional ? '?' : ''}: ${arg.type}`);\n    return `(${args.join(', ')}) => ${item.returnType}`;\n};\nconst extractTypeFromValue = (defaultValue) => {\n    const valueType = typeof defaultValue;\n    return defaultValue || valueType === 'number' || valueType === 'boolean' || valueType === 'string'\n        ? valueType\n        : null;\n};\nconst extractEnumValues = (compodocType) => {\n    const compodocJson = getCompodocJson();\n    const enumType = compodocJson?.miscellaneous?.enumerations?.find((x) => x.name === compodocType);\n    if (enumType?.childs.every((x) => x.value)) {\n        return enumType.childs.map((x) => x.value);\n    }\n    if (typeof compodocType !== 'string' || compodocType.indexOf('|') === -1) {\n        return null;\n    }\n    try {\n        return compodocType.split('|').map((value) => JSON.parse(value));\n    }\n    catch (e) {\n        return null;\n    }\n};\nexport const extractType = (property, defaultValue) => {\n    const compodocType = property.type || extractTypeFromValue(defaultValue);\n    switch (compodocType) {\n        case 'string':\n        case 'boolean':\n        case 'number':\n            return { name: compodocType };\n        case undefined:\n        case null:\n            return { name: 'other', value: 'void' };\n        default: {\n            const resolvedType = resolveTypealias(compodocType);\n            const enumValues = extractEnumValues(resolvedType);\n            return enumValues\n                ? { name: 'enum', value: enumValues }\n                : { name: 'other', value: 'empty-enum' };\n        }\n    }\n};\nconst castDefaultValue = (property, defaultValue) => {\n    const compodocType = property.type;\n    // All these checks are necessary as compodoc does not always set the type ie. @HostBinding have empty types.\n    // null and undefined also have 'any' type\n    if (['boolean', 'number', 'string', 'EventEmitter'].includes(compodocType)) {\n        switch (compodocType) {\n            case 'boolean':\n                return defaultValue === 'true';\n            case 'number':\n                return Number(defaultValue);\n            case 'EventEmitter':\n                return undefined;\n            default:\n                return defaultValue;\n        }\n    }\n    else {\n        switch (defaultValue) {\n            case 'true':\n                return true;\n            case 'false':\n                return false;\n            case 'null':\n                return null;\n            case 'undefined':\n                return undefined;\n            default:\n                return defaultValue;\n        }\n    }\n};\nconst extractDefaultValueFromComments = (property, value) => {\n    let commentValue = value;\n    property.jsdoctags.forEach((tag) => {\n        if (['default', 'defaultvalue'].includes(tag.tagName.escapedText)) {\n            const dom = new global.DOMParser().parseFromString(tag.comment, 'text/html');\n            commentValue = dom.body.textContent;\n        }\n    });\n    return commentValue;\n};\nconst extractDefaultValue = (property) => {\n    try {\n        let value = property.defaultValue?.replace(/^'(.*)'$/, '$1');\n        value = castDefaultValue(property, value);\n        if (value == null && property.jsdoctags?.length > 0) {\n            value = extractDefaultValueFromComments(property, value);\n        }\n        return value;\n    }\n    catch (err) {\n        logger.debug(`Error extracting ${property.name}: ${property.defaultValue}`);\n        return undefined;\n    }\n};\nconst resolveTypealias = (compodocType) => {\n    const compodocJson = getCompodocJson();\n    const typeAlias = compodocJson?.miscellaneous?.typealiases?.find((x) => x.name === compodocType);\n    return typeAlias ? resolveTypealias(typeAlias.rawtype) : compodocType;\n};\nexport const extractArgTypesFromData = (componentData) => {\n    const sectionToItems = {};\n    const componentClasses = FEATURES.angularFilterNonInputControls\n        ? ['inputsClass']\n        : ['propertiesClass', 'methodsClass', 'inputsClass', 'outputsClass'];\n    const compodocClasses = ['component', 'directive'].includes(componentData.type)\n        ? componentClasses\n        : ['properties', 'methods'];\n    compodocClasses.forEach((key) => {\n        const data = componentData[key] || [];\n        data.forEach((item) => {\n            const section = mapItemToSection(key, item);\n            const defaultValue = isMethod(item) ? undefined : extractDefaultValue(item);\n            const type = isMethod(item) || (section !== 'inputs' && section !== 'properties')\n                ? { name: 'other', value: 'void' }\n                : extractType(item, defaultValue);\n            const action = section === 'outputs' ? { action: item.name } : {};\n            const argType = {\n                name: item.name,\n                description: item.rawdescription || item.description,\n                type,\n                ...action,\n                table: {\n                    category: section,\n                    type: {\n                        summary: isMethod(item) ? displaySignature(item) : item.type,\n                        required: isMethod(item) ? false : !item.optional,\n                    },\n                    defaultValue: { summary: defaultValue },\n                },\n            };\n            if (!sectionToItems[section]) {\n                sectionToItems[section] = [];\n            }\n            sectionToItems[section].push(argType);\n        });\n    });\n    const SECTIONS = [\n        'properties',\n        'inputs',\n        'outputs',\n        'methods',\n        'view child',\n        'view children',\n        'content child',\n        'content children',\n    ];\n    const argTypes = {};\n    SECTIONS.forEach((section) => {\n        const items = sectionToItems[section];\n        if (items) {\n            items.forEach((argType) => {\n                argTypes[argType.name] = argType;\n            });\n        }\n    });\n    return argTypes;\n};\nexport const extractArgTypes = (component) => {\n    const componentData = getComponentData(component);\n    return componentData && extractArgTypesFromData(componentData);\n};\nexport const extractComponentDescription = (component) => {\n    const componentData = getComponentData(component);\n    return componentData && (componentData.rawdescription || componentData.description);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}